        -:    0:Source:/home/antoine/Documents/Developpement/c/stealth/src/controller/Controller.c
        -:    0:Graph:/home/antoine/Documents/Developpement/c/stealth/cmake-build-debug-coverage/CMakeFiles/stealth.dir/src/controller/Controller.c.gcno
        -:    0:Data:/home/antoine/Documents/Developpement/c/stealth/cmake-build-debug-coverage/CMakeFiles/stealth.dir/src/controller/Controller.c.gcda
        -:    0:Runs:1
        -:    1:
        -:    2:
        -:    3:#include "view/View.h"
        -:    4:#include "controller/Controller.h"
        -:    5:#include "core/Timer.h"
        -:    6:#include "view/View.h"
        -:    7:#include "Button.h"
        -:    8:
        -:    9:static int controller_in_spawn(int x, int y);
        -:   10:
function controller_run called 1 returned 100% blocks executed 94%
        1:   11:int controller_run(){
        -:   12:    View view;
        -:   13:    GameData data;
        1:   14:    view_init(&view);
        1:   14-block  0
call    0 returned 1
       1*:   15:    if(controller_init_audio(&data)) return 1;
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    %%%%%:   15-block  0
        2:   16:    while(controller_menu(&view, &data))
        1:   16-block  0
        2:   16-block  1
call    0 returned 2
branch  1 taken 1
branch  2 taken 1 (fallthrough)
        -:   17:        do{
        2:   18:            controller_init(&data);
        2:   18-block  0
call    0 returned 2
        2:   19:        }while(controller_end_game(&view,&data,controller_game_loop(&view, &data)));
call    0 returned 2
call    1 returned 2
branch  2 taken 1
branch  3 taken 1 (fallthrough)
        1:   20:    view_free(&view);
        1:   20-block  0
call    0 returned 1
        1:   21:    MLV_free_audio();
call    0 returned 1
        1:   22:    return 0;
        -:   23:}
        -:   24:
function controller_menu called 2 returned 100% blocks executed 89%
        2:   25:int controller_menu(View *view, GameData *data){
        -:   26:    MLV_Event event;
        -:   27:    MLV_Keyboard_modifier mod;
        -:   28:    MLV_Keyboard_button sym;
        -:   29:    MLV_Button_state state;
        -:   30:    MLV_Mouse_button mouse_button;
        -:   31:    int mousex, mousey;
        -:   32:    Button buttons[2];
        -:   33:    Button *selected;
        2:   34:    button_init(&buttons[0], "Fullscreen", 0.9, 0.1);
        2:   34-block  0
call    0 returned 2
        2:   35:    button_init(&buttons[1], "Play", 0.5, 0.5);
call    0 returned 2
        2:   36:    MLV_play_music(data->music_menu, 0.5f, -1);
call    0 returned 2
        -:   37:    while(1){
        -:   38:        /* buttons state */
      253:   39:        button_unselect_all(buttons, 2);
      253:   39-block  0
call    0 returned 253
      253:   40:        selected = NULL;
      253:   41:        selected = controller_pos_over_button(view, buttons,2, mousex, mousey);
call    0 returned 253
      253:   42:        if(selected) button_select(selected);
branch  0 taken 58 (fallthrough)
branch  1 taken 195
       58:   42-block  0
call    2 returned 58
        -:   43:        /* window */
      253:   44:        view_draw_menu(view, buttons, 2);
      253:   44-block  0
call    0 returned 253
      253:   45:        MLV_update_window();
call    0 returned 253
        -:   46:        /* events */
      253:   47:        MLV_get_mouse_position(&mousex, &mousey);
call    0 returned 253
      253:   48:        event = MLV_get_event(&sym, &mod,
call    0 returned 253
        -:   49:                              0,0, 0,
        -:   50:                              0, 0, &mouse_button,
        -:   51:                              &state);
      253:   52:        if(event == MLV_MOUSE_BUTTON
branch  0 taken 4 (fallthrough)
branch  1 taken 249
        4:   53:        && mouse_button == MLV_BUTTON_LEFT
        4:   53-block  0
branch  0 taken 4 (fallthrough)
branch  1 taken 0
        4:   54:        && state == MLV_PRESSED){
        4:   54-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 2
        2:   55:            if(button_is_selected(&buttons[0])){ /* windows size */
        2:   55-block  0
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
        1:   56:                if(view_is_fullscreen(view)){
        1:   56-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:   57:                    view_to_windowed(view);
    %%%%%:   57-block  0
call    0 never executed
    #####:   58:                    strcpy(buttons[0].label, "Fullscreen");
        -:   59:                }else{
        1:   60:                    view_to_fullscreen(view);
        1:   60-block  0
call    0 returned 1
        1:   61:                    strcpy(buttons[0].label, "Windowed");
        -:   62:                }
        -:   63:            }
        2:   64:            if(button_is_selected(&buttons[1])){ /* play */
        2:   64-block  0
call    0 returned 2
branch  1 taken 1 (fallthrough)
branch  2 taken 1
        1:   65:                return 1;
        1:   65-block  0
        -:   66:            }
        -:   67:        }
      252:   68:        if(event == MLV_KEY && state == MLV_PRESSED){
      252:   68-block  0
branch  0 taken 2 (fallthrough)
branch  1 taken 250
        2:   68-block  1
branch  2 taken 1 (fallthrough)
branch  3 taken 1
        1:   69:            if(sym == MLV_KEYBOARD_ESCAPE)
        1:   69-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:   70:                return 0;
        1:   70-block  0
    #####:   71:            else if(sym == MLV_KEYBOARD_RETURN){
    %%%%%:   71-block  0
branch  0 never executed
branch  1 never executed
        -:   72:                /* play */
    #####:   73:                return 1;
    %%%%%:   73-block  0
        -:   74:            }
        -:   75:        }
        -:   76:        /* Cap refresh rate */
      251:   77:        MLV_delay_according_to_frame_rate();
      251:   77-block  0
call    0 returned 251
        -:   78:    }
        -:   79:}
        -:   80:
function controller_game_loop called 2 returned 100% blocks executed 83%
        2:   81:int controller_game_loop(View *view, GameData *data) {
        2:   82:    int detection_overview = 0;
        2:   83:    MLV_Keyboard_button touche = MLV_KEYBOARD_NONE;
        -:   84:    MLV_Button_state state;
        -:   85:    int mana;
        2:   86:    MLV_play_music(data->music_room, 0.5f, -1);
        2:   86-block  0
call    0 returned 2
        2:   87:    int i, win, pause = 0;
        -:   88:    /* While user didn't press any move key we stay in pause state so 
        -:   89:    user can see the room and where the relics are ...*/
     2109:   90:    while (!(win = controller_win(data))) {
     2109:   90-block  0
call    0 returned 2109
branch  1 taken 2108
branch  2 taken 1 (fallthrough)
        -:   91:        /* Display the current frame, sample function */
     2108:   92:        if (!pause){
     2108:   92-block  0
branch  0 taken 2108 (fallthrough)
branch  1 taken 0
     2108:   93:            controller_update_time(data);
     2108:   93-block  0
call    0 returned 2108
     2108:   94:            controller_check_player(data);
call    0 returned 2108
     2108:   95:            if(controller_check_guards_find_player(data)){
call    0 returned 2108
        -:   96:                ; /* Player have been caught then display end game screen */
        -:   97:            }
     2108:   98:            controller_check_guard_panic(data);
call    0 returned 2108
        -:   99:        }
     2108:  100:        controller_update_view(data, view);
     2108:  100-block  0
call    0 returned 2108
     2108:  101:        if(detection_overview)
branch  0 taken 0 (fallthrough)
branch  1 taken 2108
    #####:  102:            for(i = 0; i < GUARD_NUMBER; i++){ /* just for fun and debugging */
    %%%%%:  102-block  0
    %%%%%:  102-block  1
branch  0 never executed
branch  1 never executed
    #####:  103:                draw_intersections_with_tiles(view, &data->room
    #####:  104:                                              , &data->player.position
    #####:  105:                                              , &data->guards[i].position);
    %%%%%:  105-block  0
call    0 never executed
        -:  106:            }
     2108:  107:        MLV_update_window();
     2108:  107-block  0
call    0 returned 2108
        -:  108:        /* get keyboard events */
     2108:  109:        MLV_get_event(&touche, NULL, NULL, NULL,
call    0 returned 2108
        -:  110:                      NULL,NULL, NULL, NULL,&state);
        -:  111:        /* quit with x */
     2108:  112:        if (MLV_get_keyboard_state(MLV_KEYBOARD_p) == MLV_PRESSED){
call    0 returned 2108
branch  1 taken 0 (fallthrough)
branch  2 taken 2108
        -:  113:            /* Make the game pause and unpause ?*/
    #####:  114:            pause = pause ? 0 : 1;
    %%%%%:  114-block  0
        -:  115:        }
     2108:  116:        if(!MLV_get_keyboard_state(MLV_KEYBOARD_ESCAPE))
     2108:  116-block  0
call    0 returned 2108
branch  1 taken 1 (fallthrough)
branch  2 taken 2107
        1:  117:            break;
        1:  117-block  0
        -:  118:        /* detection overview */
     2107:  119:        if (!MLV_get_keyboard_state(MLV_KEYBOARD_o))
     2107:  119-block  0
call    0 returned 2107
branch  1 taken 0 (fallthrough)
branch  2 taken 2107
    #####:  120:            detection_overview = !detection_overview;
    %%%%%:  120-block  0
     2107:  121:        if (!pause){
     2107:  121-block  0
branch  0 taken 2107 (fallthrough)
branch  1 taken 0
        -:  122:            /* deactivate skill by default */
     2107:  123:            player_deactivate_all_skills(&data->player);
     2107:  123-block  0
call    0 returned 2107
        -:  124:            /* SPEED SKILL */
     2107:  125:            if(!MLV_get_keyboard_state(MLV_KEYBOARD_RSHIFT)
call    0 returned 2107
branch  1 taken 2107 (fallthrough)
branch  2 taken 0
     2107:  126:            || !MLV_get_keyboard_state(MLV_KEYBOARD_LSHIFT)){
     2107:  126-block  0
call    0 returned 2107
branch  1 taken 72 (fallthrough)
branch  2 taken 2035
       72:  127:                skill_activate(player_skill(&data->player, SPEED));
       72:  127-block  0
call    0 returned 72
call    1 returned 72
        -:  128:            }
        -:  129:            /* INVISIBILITY SKILL */
     2107:  130:            if(!MLV_get_keyboard_state(MLV_KEYBOARD_SPACE)){
     2107:  130-block  0
call    0 returned 2107
branch  1 taken 0 (fallthrough)
branch  2 taken 2107
    #####:  131:                skill_activate(player_skill(&data->player, INVISIBILITY));
    %%%%%:  131-block  0
call    0 never executed
call    1 never executed
        -:  132:            }
        -:  133:            /* regenerate consumed mana in the room */
     2107:  134:            mana = player_consume_mana(&data->player);
     2107:  134-block  0
call    0 returned 2107
     2107:  135:            room_add_mana(&data->room, mana);
call    0 returned 2107
     2107:  136:            data->score.mana += mana;
        -:  137:            /* check if skill should still be activated depending on the players mana */
     2107:  138:            player_update_skills_state(&data->player);
call    0 returned 2107
        -:  139:            /* Move entities */
     2107:  140:            controller_move_player(data, get_direction_from_keyboard());
call    0 returned 2107
call    1 returned 2107
     2107:  141:            controller_move_guards(data);
call    0 returned 2107
        -:  142:        }
        -:  143:        /* Cap refresh rate */
     2107:  144:        MLV_delay_according_to_frame_rate();
     2107:  144-block  0
call    0 returned 2107
        -:  145:    }
        2:  146:    data->score.time = timer_get_delta(data->timer);
        2:  146-block  0
call    0 returned 2
        2:  147:    return win;
        -:  148:}
        -:  149:
function controller_end_game called 2 returned 100% blocks executed 100%
        2:  150:int controller_end_game(View *view, GameData *data, int win){
        -:  151:    MLV_Event event;
        -:  152:    MLV_Keyboard_modifier mod;
        -:  153:    MLV_Keyboard_button sym;
        -:  154:    MLV_Button_state state;
        2:  155:    Score scores_mana[SCORE_SAVED + 1] = {0};
        2:  156:    Score scores_time[SCORE_SAVED + 1] = {0};
        2:  157:    MLV_stop_music();
        2:  157-block  0
call    0 returned 2
        2:  158:    MLV_play_music(data->music_menu, 0.5f, -1);
call    0 returned 2
        2:  159:    controller_save_score(view, data);
call    0 returned 2
        2:  160:    int nmana = score_read("resources/score_mana", scores_mana, SCORE_SAVED);
call    0 returned 2
        2:  161:    int ntime = score_read("resources/score_time", scores_time, SCORE_SAVED);
call    0 returned 2
        -:  162:    while(1){
     1219:  163:        view_draw_end_msg(view, data, win);
     1219:  163-block  0
call    0 returned 1219
     1219:  164:        view_draw_score_board(view, data, scores_mana, nmana, scores_time, ntime);
call    0 returned 1219
     1219:  165:        MLV_update_window();
call    0 returned 1219
     1219:  166:        event = MLV_get_event(&sym, &mod,
call    0 returned 1219
        -:  167:                              0,0, 0,0, 0, 0,
        -:  168:                              &state);
     1219:  169:        if(event == MLV_KEY && state == MLV_PRESSED){
branch  0 taken 4 (fallthrough)
branch  1 taken 1215
        4:  169-block  0
branch  2 taken 2 (fallthrough)
branch  3 taken 2
        2:  170:            if(sym == MLV_KEYBOARD_ESCAPE)
        2:  170-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        1:  171:                return 0;
        1:  171-block  0
        1:  172:            else if(sym == MLV_KEYBOARD_r){
        1:  172-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        -:  173:                /* Retry */
        1:  174:                return 1;
        1:  174-block  0
        -:  175:            }
        -:  176:        }
        -:  177:        /* Cap refresh rate */
     1217:  178:        MLV_delay_according_to_frame_rate();
     1217:  178-block  0
call    0 returned 1217
        -:  179:    }
        -:  180:}
        -:  181:
function controller_save_score called 2 returned 100% blocks executed 91%
        2:  182:void controller_save_score(View *view, GameData *data){
        -:  183:    int i;
        2:  184:    int win = controller_win((const GameData *) &data->player);
        2:  184-block  0
call    0 returned 2
        2:  185:    Score scores_mana[SCORE_SAVED + 1] = {0};
        2:  186:    Score scores_time[SCORE_SAVED + 1] = {0};
       42:  187:    for(i = 0; i < SCORE_SAVED; i++) scores_time[i].time = __LONG_MAX__;
       40:  187-block  0
       42:  187-block  1
branch  0 taken 40
branch  1 taken 2 (fallthrough)
       42:  188:    for(i = 0; i < SCORE_SAVED; i++) scores_mana[i].mana = __INT_MAX__;
        2:  188-block  0
       40:  188-block  1
       42:  188-block  2
branch  0 taken 40
branch  1 taken 2 (fallthrough)
        2:  189:    int nmana = score_read("resources/score_mana", scores_mana, SCORE_SAVED);
        2:  189-block  0
call    0 returned 2
        2:  190:    int ntime = score_read("resources/score_time", scores_time, SCORE_SAVED);
call    0 returned 2
        2:  191:    view_draw_score_board(view, data, scores_mana, nmana, scores_time, ntime);
call    0 returned 2
        2:  192:    view_draw_end_msg(view, data, win);
call    0 returned 2
        2:  193:    MLV_update_window();
call    0 returned 2
        2:  194:    if(win){
branch  0 taken 1 (fallthrough)
branch  1 taken 1
        -:  195:        /* check if in top scores */
        1:  196:        int in_top_mana = !nmana
       1*:  197:                || score_cmp_mana(&scores_mana[SCORE_SAVED - 1], &data->score) > 0;
        1:  197-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  197-block  1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1:  197-block  2
    %%%%%:  197-block  3
        1:  198:        int in_top_time = !ntime
       1*:  199:                || score_cmp_time(&scores_time[SCORE_SAVED - 1], &data->score) > 0;
        1:  199-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  199-block  1
call    2 returned 1
branch  3 taken 1 (fallthrough)
branch  4 taken 0
        1:  199-block  2
    %%%%%:  199-block  3
       1*:  200:        if(in_top_mana || in_top_time){
        1:  200-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 1
    %%%%%:  200-block  1
branch  2 never executed
branch  3 never executed
        -:  201:            /* ask name */
        1:  202:            view_ask_string(view, "Name: ", NAME_LENGTH, data->score.name);
        1:  202-block  0
call    0 returned 1
        -:  203:            /* put in mana score board */
        1:  204:            if(in_top_mana){
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  205:                scores_mana[SCORE_SAVED] = data->score;
        1:  206:                qsort(scores_mana, SCORE_SAVED + 1, sizeof(Score), score_cmp_mana);
        1:  206-block  0
call    0 returned 1
        1:  207:                score_write("resources/score_mana",
        1:  208:                            scores_mana, MIN(nmana + 1, SCORE_SAVED));
call    0 returned 1
        -:  209:            }
        -:  210:            /* put in time score board */
        1:  211:            if(in_top_time){
        1:  211-block  0
branch  0 taken 1 (fallthrough)
branch  1 taken 0
        1:  212:                scores_time[SCORE_SAVED] = data->score;
        1:  213:                qsort(scores_time, SCORE_SAVED + 1, sizeof(Score), score_cmp_time);
        1:  213-block  0
call    0 returned 1
        1:  214:                score_write("resources/score_time",
        1:  215:                            scores_time, MIN(ntime + 1, SCORE_SAVED));
call    0 returned 1
        -:  216:            }
        -:  217:        }
        -:  218:    }
        2:  219:}
        -:  220:
function controller_pos_over_button called 253 returned 100% blocks executed 100%
      253:  221:Button * controller_pos_over_button(const View *view, Button *buttons, int n, int x, int y){
        -:  222:    int i, bw, bh;
      663:  223:    for(i = 0; i < n; i++){
      253:  223-block  0
      410:  223-block  1
      663:  223-block  2
branch  0 taken 468
branch  1 taken 195 (fallthrough)
      468:  224:        view_get_button_size(view, buttons + i, &bw, &bh);
      468:  224-block  0
call    0 returned 468
      468:  225:        if(x >= buttons[i].x * view->width - bw / 2
branch  0 taken 230 (fallthrough)
branch  1 taken 238
      230:  226:        && x <= buttons[i].x * view->width + bw / 2
      230:  226-block  0
branch  0 taken 125 (fallthrough)
branch  1 taken 105
      125:  227:        && y >= buttons[i].y * view->height - bh / 2
      125:  227-block  0
branch  0 taken 116 (fallthrough)
branch  1 taken 9
      116:  228:        && y <= buttons[i].y * view->height + bh / 2)
      116:  228-block  0
branch  0 taken 58 (fallthrough)
branch  1 taken 58
       58:  229:            return buttons + i;
       58:  229-block  0
        -:  230:    }
      195:  231:    return NULL;
      195:  231-block  0
        -:  232:}
        -:  233:
function controller_update_view called 2108 returned 100% blocks executed 100%
     2108:  234:void controller_update_view(GameData *data, View *view){
     2108:  235:    view_draw_room(view, &data->room);
     2108:  235-block  0
call    0 returned 2108
        -:  236:    /*view_draw_util(view);*/
     2108:  237:    view_draw_info(view, data);
call    0 returned 2108
     2108:  238:    view_draw_relics(view, data->relics);
call    0 returned 2108
     2108:  239:    view_draw_guards(view, data);
call    0 returned 2108
     2108:  240:    view_draw_player(view, &data->player);
call    0 returned 2108
     2108:  241:}
        -:  242:
function controller_init_relics called 2 returned 100% blocks executed 93%
        2:  243:void controller_init_relics(GameData *data){
        -:  244:    int i, posx, posy;
        -:  245:    Position pos;
        8:  246:    for (i = 0; i < RELICS_NUMBER; i++){
        2:  246-block  0
        8:  246-block  1
branch  0 taken 6
branch  1 taken 2 (fallthrough)
        -:  247:        do {
       11:  248:            posx = int_rand(1, ROOM_WIDTH - 1);
       11:  248-block  0
call    0 returned 11
       11:  249:            posy = int_rand(1, ROOM_HEIGHT - 1);
call    0 returned 11
    #####:  250:        }while((posx < 3 && posy < 3)
    %%%%%:  250-block  0
branch  0 never executed
branch  1 never executed
       11:  251:               || room_get_tile_type(&data->room, posy, posx) != EMPTY);
branch  0 taken 0 (fallthrough)
branch  1 taken 11
       11:  251-block  0
call    2 returned 11
branch  3 taken 5
branch  4 taken 6 (fallthrough)
        6:  252:        tile_set_type(
        6:  252-block  0
call    0 returned 6
call    1 returned 6
        -:  253:                room_get_tile(&data->room, posy, posx)
        -:  254:                , RELIC);
        6:  255:        position_init(&pos, posx, posy);
call    0 returned 6
        6:  256:        init_relic(&data->relics[i], pos);
call    0 returned 6
        -:  257:    }
        2:  258:}
        -:  259:
function controller_init_audio called 1 returned 100% blocks executed 82%
        1:  260:int controller_init_audio(GameData *data){
        1:  261:    if( MLV_init_audio() ){
        1:  261-block  0
call    0 returned 1
branch  1 taken 0 (fallthrough)
branch  2 taken 1
    #####:  262:        fprintf(stderr,"Could not load audio lib.");
    %%%%%:  262-block  0
call    0 never executed
    #####:  263:        return 1;
        -:  264:    }
        1:  265:    data->music_room = MLV_load_music("resources/music/stealth.ogg");
        1:  265-block  0
call    0 returned 1
        1:  266:    data->music_alarm = MLV_load_music("resources/music/alarm.ogg");
call    0 returned 1
        1:  267:    data->music_menu = MLV_load_music("resources/music/menu.ogg");
call    0 returned 1
        1:  268:    data->sound_mana = MLV_load_sound("resources/music/mana.ogg");
call    0 returned 1
        1:  269:    data->sound_relic = MLV_load_sound("resources/music/relic.ogg");
call    0 returned 1
        1:  270:    return 0;
        -:  271:}
        -:  272:
function controller_init called 2 returned 100% blocks executed 100%
        2:  273:void controller_init(GameData *data){
        2:  274:    room_init(&data->room);
        2:  274-block  0
call    0 returned 2
        -:  275:    /* player */
        2:  276:    player_init(&(data->player), 2, 2);
call    0 returned 2
        -:  277:    /* guards */
        -:  278:    int i, x, y;
       12:  279:    for(i = 0; i < GUARD_NUMBER; i++){
       12:  279-block  0
branch  0 taken 10
branch  1 taken 2 (fallthrough)
        -:  280:        do {
       13:  281:            room_random_position(&data->room, EMPTY, &x, &y);
       13:  281-block  0
call    0 returned 13
       13:  282:        } while (x < 8 || y < 8);
branch  0 taken 2
branch  1 taken 11 (fallthrough)
       11:  282-block  0
branch  2 taken 1
branch  3 taken 10 (fallthrough)
        -:  283:        /* Guard can't spawn too close to player else they will see 
        -:  284:        him before player can even move */
       10:  285:        guard_init(&(data->guards[i]) , x, y);
       10:  285-block  0
call    0 returned 10
        -:  286:    }
        -:  287:    /* mana */
        2:  288:    room_add_mana(&data->room, MANA_TILES_NUMBER);
        2:  288-block  0
call    0 returned 2
        -:  289:    /* Relics */
        2:  290:    controller_init_relics(data);
call    0 returned 2
        -:  291:    /* Time */
        2:  292:    data->timer = new_timer();
call    0 returned 2
        2:  293:    timer_start(data->timer);
call    0 returned 2
        2:  294:}
        -:  295:
function entity_move called 12642 returned 100% blocks executed 67%
    12642:  296:void entity_move(Position *position, double speed, Direction direction){
   12642*:  297:    assert(position);
    12642:  297-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 12642
    %%%%%:  297-block  1
call    2 never executed
    12642:  298:    position->x += COMPUTE_MOVE_DIST(speed) * direction_factor[direction][0];
    12642:  299:    position->y += COMPUTE_MOVE_DIST(speed) * direction_factor[direction][1];
    12642:  300:}
        -:  301:
function controller_move_player called 2107 returned 100% blocks executed 88%
     2107:  302:void controller_move_player(GameData *data, Direction direction){
    2107*:  303:    assert(data);
     2107:  303-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2107
    %%%%%:  303-block  1
call    2 never executed
     2107:  304:    player_update_speed(&data->player, direction);
     2107:  304-block  0
call    0 returned 2107
     2107:  305:    entity_move(&data->player.position, data->player.speed, direction);
call    0 returned 2107
     2107:  306:    if(room_resolve_collision(&data->room, &data->player.position)){
call    0 returned 2107
branch  1 taken 74 (fallthrough)
branch  2 taken 2033
        -:  307:        /* collided */
        -:  308:        /* The player is hitting the wall, so the speed must be reset to init speed */
       74:  309:        player_update_speed(&data->player, STILL);
       74:  309-block  0
call    0 returned 74
        -:  310:    }
     2107:  311:}
        -:  312:
function controller_move_guards called 2107 returned 100% blocks executed 92%
     2107:  313:void controller_move_guards(GameData *data){
    2107*:  314:    assert(data);
     2107:  314-block  0
branch  0 taken 0 (fallthrough)
branch  1 taken 2107
    %%%%%:  314-block  1
call    2 never executed
        -:  315:    int i;
    12642:  316:    for(i = 0; i < GUARD_NUMBER; i++){
     2107:  316-block  0
    10535:  316-block  1
    12642:  316-block  2
branch  0 taken 10535
branch  1 taken 2107 (fallthrough)
    10535:  317:        guard_update_speed(&data->guards[i]);
    10535:  317-block  0
call    0 returned 10535
    10535:  318:        entity_move(&data->guards[i].position
call    0 returned 10535
call    1 returned 10535
        -:  319:                , data->guards[i].speed
        -:  320:                , guard_update_direction(&data->guards[i]));
    10535:  321:        if(room_resolve_collision(&data->room, &data->guards[i].position)){ /* collided */
call    0 returned 10535
branch  1 taken 1879 (fallthrough)
branch  2 taken 8656
        -:  322:            /* The guard is hitting the wall, so the speed and the direction must be updated again */
     1879:  323:            guard_update_speed(&data->guards[i]);
     1879:  323-block  0
call    0 returned 1879
     1879:  324:            guard_update_direction(&data->guards[i]);
call    0 returned 1879
        -:  325:        }
        -:  326:    }
     2107:  327:}
        -:  328:
function controller_make_guards_panic called 3 returned 100% blocks executed 100%
        3:  329:void controller_make_guards_panic(GameData *data){
        -:  330:    int i;
       18:  331:    for(i = 0; i < GUARD_NUMBER; i++){
        3:  331-block  0
       15:  331-block  1
       18:  331-block  2
branch  0 taken 15
branch  1 taken 3 (fallthrough)
       15:  332:        if (guard_is_panicking(&data->guards[i])){
       15:  332-block  0
call    0 returned 15
branch  1 taken 10 (fallthrough)
branch  2 taken 5
        -:  333:            /* Then his panic count is reset */
       10:  334:            guard_reset_panic_count(&data->guards[i]);
       10:  334-block  0
call    0 returned 10
        5:  335:        } else guard_panic(&data->guards[i]);
        5:  335-block  0
call    0 returned 5
        -:  336:    }
        3:  337:}
        -:  338:
function controller_check_guard_panic called 2108 returned 100% blocks executed 91%
     2108:  339:int controller_check_guard_panic(GameData *data){
        -:  340:    int i, j;
        -:  341:    /* update all panic counters */
     2108:  342:    int panicking = guard_is_panicking(&data->guards[0]);
     2108:  342-block  0
call    0 returned 2108
        -:  343:    /* check if any guard see a missing relic */
    12644:  344:    for(i = 0; i < GUARD_NUMBER; i++) {
    10536:  344-block  0
    12644:  344-block  1
branch  0 taken 10539
branch  1 taken 2105 (fallthrough)
    10539:  345:        guard_update_panic_count(&data->guards[i]);
    10539:  345-block  0
call    0 returned 10539
    42150:  346:        for (j = 0; j < RELICS_NUMBER; j++) {
    31611:  346-block  0
    42150:  346-block  1
branch  0 taken 31614
branch  1 taken 10536 (fallthrough)
    31614:  347:            if (controller_guard_sees_missing_relic(&data->room, &data->guards[i], &data->relics[j])) {
    31614:  347-block  0
call    0 returned 31614
branch  1 taken 3 (fallthrough)
branch  2 taken 31611
        -:  348:                /* the missing relic is being noticed by all guards now */
        3:  349:                data->relics[j].noticed = 1;
        -:  350:                /* Play alarm sound if not already panicking */
        3:  351:                if(!guard_is_panicking(&data->guards[i])){
        3:  351-block  0
call    0 returned 3
branch  1 taken 1 (fallthrough)
branch  2 taken 2
        1:  352:                    MLV_stop_music();
        1:  352-block  0
call    0 returned 1
        1:  353:                    MLV_play_music(data->music_alarm, 1.5f, -1);
call    0 returned 1
        -:  354:                }
        -:  355:                /* every guard goes panicking */
        3:  356:                controller_make_guards_panic(data);
        3:  356-block  0
call    0 returned 3
        3:  357:                return 1;
        -:  358:            }
        -:  359:        }
        -:  360:    }
        -:  361:    /* No more panicking, then restart music */
     2105:  362:    if(panicking != guard_is_panicking(&data->guards[0])){
     2105:  362-block  0
call    0 returned 2105
branch  1 taken 0 (fallthrough)
branch  2 taken 2105
    #####:  363:        MLV_stop_music();
    %%%%%:  363-block  0
call    0 never executed
    #####:  364:        MLV_play_music(data->music_room, 0.5f, -1);
call    0 never executed
        -:  365:    }
     2105:  366:    return 0;
     2105:  366-block  0
        -:  367:}
        -:  368:
function controller_check_player called 2108 returned 100% blocks executed 100%
     2108:  369:void controller_check_player(GameData *data){
        -:  370:    int i;
     2108:  371:    Position current_tile = {
     2108:  372:            .x = (int) data->player.position.x,
     2108:  373:            .y = (int) data->player.position.y
        -:  374:    };
     2108:  375:    Tile *tile = room_get_tile(&data->room, (int) current_tile.y, (int) current_tile.x);
     2108:  375-block  0
call    0 returned 2108
        -:  376:    /* Take the mana on the tile if exists */
     2108:  377:    if(tile->type == MANA){
branch  0 taken 64 (fallthrough)
branch  1 taken 2044
        -:  378:        /* SPEED skill consume 2 mana per frame 
        -:  379:        and INVISIBILITY consume 1 mana per frame
        -:  380:        and 60 fps so player need 60 mana to speed for a single frame
        -:  381:        there's a lot of mana tiles also so :
        -:  382:        if tiles get 3 mana each tile 20 tiles = 1 second of speed or 2 second of invisibility seems reasonable*/
       64:  383:        data->player.mana += 3; /* Previous was 1 */
       64:  384:        tile->type = EMPTY;
        -:  385:        /* mana sound */
       64:  386:        MLV_play_sound(data->sound_mana, 0.1f);
       64:  386-block  0
call    0 returned 64
        -:  387:    }
        -:  388:    /* Look if he is on a relic tile and the relic isn't taken so he takes it*/
     2108:  389:    if (tile->type == RELIC){
     2108:  389-block  0
branch  0 taken 25 (fallthrough)
branch  1 taken 2083
        -:  390:        /* Player is on a relic Tile */
        -:  391:        /* Lets look wich one */
      100:  392:        for (i = 0; i < RELICS_NUMBER; i++){
       25:  392-block  0
       75:  392-block  1
      100:  392-block  2
branch  0 taken 75
branch  1 taken 25 (fallthrough)
        -:  393:            /* No need to calculate pos if the relic is taken even if not the right one */
       75:  394:            if (!data->relics[i].stolen
       75:  394-block  0
branch  0 taken 23 (fallthrough)
branch  1 taken 52
       23:  395:                && position_eq(&current_tile, &data->relics[i].position)){
       23:  395-block  0
call    0 returned 23
branch  1 taken 3 (fallthrough)
branch  2 taken 20
        -:  396:                /* It's this relic and relic not taken */
        3:  397:                relic_steal(&data->relics[i]);
        3:  397-block  0
call    0 returned 3
        -:  398:                /* relic steal sound */
        3:  399:                MLV_play_sound(data->sound_relic, 0.5f);
call    0 returned 3
        -:  400:            }
        -:  401:        }
        -:  402:    }
     2108:  403:}
        -:  404:
function controller_check_guards_find_player called 2108 returned 100% blocks executed 100%
     2108:  405:int controller_check_guards_find_player(GameData *data){
        -:  406:    int i;
    11780:  407:    for(i = 0; i < GUARD_NUMBER; i++){
     2108:  407-block  0
     9672:  407-block  1
    11780:  407-block  2
branch  0 taken 9971
branch  1 taken 1809 (fallthrough)
        -:  408:        /* player in view range */
    19942:  409:        if(position_dist(&data->guards[i].position, &data->player.position)
     9971:  409-block  0
call    0 returned 9971
branch  1 taken 367 (fallthrough)
branch  2 taken 9604
     9971:  410:           < guard_view_range(&data->guards[i])
call    0 returned 9971
        -:  411:           /* player is visible*/
      367:  412:           && !skill_is_activated(player_skill(&data->player, INVISIBILITY))
      367:  412-block  0
call    0 returned 367
call    1 returned 367
branch  2 taken 367 (fallthrough)
branch  3 taken 0
        -:  413:           /* no wall between them */
      367:  414:           && !room_tile_between(&data->room, &data->guards[i].position, &data->player.position, WALL)){
      367:  414-block  0
call    0 returned 367
branch  1 taken 299 (fallthrough)
branch  2 taken 68
      299:  415:            return 1;
      299:  415-block  0
        -:  416:        }
        -:  417:    }
     1809:  418:    return 0;
     1809:  418-block  0
        -:  419:}
        -:  420:
function controller_stolen_relic_count called 4219 returned 100% blocks executed 100%
     4219:  421:int controller_stolen_relic_count(const GameData *data){
        -:  422:    int i, count;
    16876:  423:    for(i = count = 0; i < RELICS_NUMBER; i++)
     4219:  423-block  0
    12657:  423-block  1
    16876:  423-block  2
branch  0 taken 12657
branch  1 taken 4219 (fallthrough)
    12657:  424:        if(relic_is_stolen(&data->relics[i])) count++;
    12657:  424-block  0
call    0 returned 12657
branch  1 taken 8265 (fallthrough)
branch  2 taken 4392
     8265:  424-block  1
     4219:  425:    return count;
     4219:  425-block  0
        -:  426:}
        -:  427:
        -:  428:
function controller_win called 2111 returned 100% blocks executed 100%
     2111:  429:int controller_win(const GameData *data){
        -:  430:    return
     2111:  431:    controller_stolen_relic_count(data) == RELICS_NUMBER
     2111:  431-block  0
call    0 returned 2111
     2111:  432:    && controller_in_spawn(data->player.position.x, data->player.position.y);
branch  0 taken 775 (fallthrough)
branch  1 taken 1336
      775:  432-block  0
call    2 returned 775
branch  3 taken 2 (fallthrough)
branch  4 taken 773
        2:  432-block  1
     2109:  432-block  2
     2111:  432-block  3
        -:  433:    ;
        -:  434:}
        -:  435:
function controller_update_time called 2108 returned 100% blocks executed 100%
     2108:  436:void controller_update_time(GameData *data){
     2108:  437:    timer_update(data->timer);
     2108:  437-block  0
call    0 returned 2108
     2108:  438:}
        -:  439:
function get_direction_from_keyboard called 2107 returned 100% blocks executed 100%
     2107:  440:Direction get_direction_from_keyboard() {
        -:  441:    static Direction direction;
     2107:  442:    if (!MLV_get_keyboard_state(MLV_KEYBOARD_z)
     2107:  442-block  0
call    0 returned 2107
branch  1 taken 691 (fallthrough)
branch  2 taken 1416
      691:  443:        && !MLV_get_keyboard_state(MLV_KEYBOARD_d))
      691:  443-block  0
call    0 returned 691
branch  1 taken 258 (fallthrough)
branch  2 taken 433
      258:  444:        direction = NE;
      258:  444-block  0
     1849:  445:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_s) == MLV_PRESSED
     1849:  445-block  0
call    0 returned 1849
branch  1 taken 759 (fallthrough)
branch  2 taken 1090
      759:  446:             && MLV_get_keyboard_state(MLV_KEYBOARD_d) == MLV_PRESSED)
      759:  446-block  0
call    0 returned 759
branch  1 taken 336 (fallthrough)
branch  2 taken 423
      336:  447:        direction = SE;
      336:  447-block  0
     1513:  448:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_s) == MLV_PRESSED
     1513:  448-block  0
call    0 returned 1513
branch  1 taken 423 (fallthrough)
branch  2 taken 1090
      423:  449:             && MLV_get_keyboard_state(MLV_KEYBOARD_q) == MLV_PRESSED)
      423:  449-block  0
call    0 returned 423
branch  1 taken 268 (fallthrough)
branch  2 taken 155
      268:  450:        direction = SO;
      268:  450-block  0
     1245:  451:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_z) == MLV_PRESSED
     1245:  451-block  0
call    0 returned 1245
branch  1 taken 433 (fallthrough)
branch  2 taken 812
      433:  452:             && MLV_get_keyboard_state(MLV_KEYBOARD_q) == MLV_PRESSED)
      433:  452-block  0
call    0 returned 433
branch  1 taken 212 (fallthrough)
branch  2 taken 221
      212:  453:        direction = NO;
      212:  453-block  0
     1033:  454:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_z) == MLV_PRESSED)
     1033:  454-block  0
call    0 returned 1033
branch  1 taken 221 (fallthrough)
branch  2 taken 812
      221:  455:        direction = N;
      221:  455-block  0
      812:  456:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_q) == MLV_PRESSED)
      812:  456-block  0
call    0 returned 812
branch  1 taken 265 (fallthrough)
branch  2 taken 547
      265:  457:        direction = O;
      265:  457-block  0
      547:  458:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_s) == MLV_PRESSED)
      547:  458-block  0
call    0 returned 547
branch  1 taken 155 (fallthrough)
branch  2 taken 392
      155:  459:        direction = S;
      155:  459-block  0
      392:  460:    else if (MLV_get_keyboard_state(MLV_KEYBOARD_d) == MLV_PRESSED)
      392:  460-block  0
call    0 returned 392
branch  1 taken 294 (fallthrough)
branch  2 taken 98
      294:  461:        direction = E;
      294:  461-block  0
       98:  462:    else direction = STILL;
       98:  462-block  0
     2107:  463:    return direction;
     2107:  463-block  0
        -:  464:}
        -:  465:
function controller_guard_sees_missing_relic called 31614 returned 100% blocks executed 100%
    31614:  466:int controller_guard_sees_missing_relic(const Room *room, const Guard *guard, const Relic *relic){
    52263:  467:    if(relic->stolen && position_dist(&guard->position, &relic->position)
    31614:  467-block  0
branch  0 taken 20649 (fallthrough)
branch  1 taken 10965
    20649:  467-block  1
call    2 returned 20649
branch  3 taken 1159 (fallthrough)
branch  4 taken 19490
    20649:  468:                       < guard_view_range(guard)
call    0 returned 20649
     1159:  469:       && !room_tile_between(room, &guard->position, &relic->position, WALL)
     1159:  469-block  0
call    0 returned 1159
branch  1 taken 1159 (fallthrough)
branch  2 taken 0
     1159:  470:       && !relic->noticed /* can't panic for seeing a stolen relic twice */
     1159:  470-block  0
branch  0 taken 3 (fallthrough)
branch  1 taken 1156
        -:  471:            ){
        3:  472:        return 1;
        3:  472-block  0
        -:  473:    }
    31611:  474:    return 0;
    31611:  474-block  0
        -:  475:}
        -:  476:
        -:  477:
function controller_in_spawn called 775 returned 100% blocks executed 100%
      775:  478:static int controller_in_spawn(int x, int y){
        -:  479:    return x >= 1
      775:  480:           && x <= 3
      775:  480-block  0
branch  0 taken 206 (fallthrough)
branch  1 taken 569
      206:  481:           && y >= 1
      206:  481-block  0
branch  0 taken 206 (fallthrough)
branch  1 taken 0
     1550:  482:           && y <= 3;
      775:  482-block  0
branch  0 taken 775 (fallthrough)
branch  1 taken 0
      206:  482-block  1
branch  2 taken 2 (fallthrough)
branch  3 taken 204
        2:  482-block  2
      773:  482-block  3
      775:  482-block  4
        -:  483:}
